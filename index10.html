<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Preencher PDF - Ajuste de Paciente/Procedimento</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding:20px; background:#f7f7fb;}
    .card{background:white;padding:18px;border-radius:10px;box-shadow:0 6px 18px rgba(25,25,40,0.06);max-width:900px;margin:12px auto;}
    label{display:block;margin-top:10px;font-weight:600}
    input[type="text"], textarea, select{width:100%;padding:8px;border-radius:6px;border:1px solid #ddd;margin-top:6px;box-sizing:border-box}
    .row{display:flex;gap:10px}
    .col{flex:1}
    button{background:#2563eb;color:white;border:none;padding:10px 14px;border-radius:8px;cursor:pointer;margin-top:12px}
    small{color:#666}
    .preview{margin-top:18px;text-align:center}
  </style>
</head>
<body>
  <div class="card">
    <h2>Gerar PDF com nome do paciente e procedimento (corrigido)</h2>
    <p>Faça upload do PDF modelo (formulário em branco). Informe o paciente e procedimento. O sistema tentará quebrar linhas e ajustar fonte para que o texto caiba.</p>

    <label>Arquivo PDF modelo (template)</label>
    <input id="filePdf" type="file" accept="application/pdf" />

    <label>Paciente</label>
    <input id="paciente" type="text" value="Luzimar Silva do Rego Nascimento" />

    <label>Procedimento</label>
    <textarea id="procedimento" rows="3">EXEMPLO DE PROCEDIMENTO QUE PODE SER BEM LONGO E PRECISA QUEBRAR LINHAS ADEQUADAMENTE</textarea>

    <div class="row">
      <div class="col">
        <label>Tipo de ajuste</label>
        <select id="strategy">
          <option value="multiline">Quebra em várias linhas (recomendado)</option>
          <option value="shrink">Encolher fonte se necessário</option>
        </select>
      </div>
      <div class="col">
        <label>Max chars / linha (paciente)</label>
        <input id="maxChars" type="text" value="20" />
      </div>
    </div>

    <button id="generate">Gerar PDF preenchido</button>
    <small>O PDF será gerado localmente no navegador.</small>

    <div class="preview" id="preview"></div>
  </div>

  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <script>
    // Configurações de posição: ajuste estes valores conforme o seu template PDF.
    // Você deve medir (em pontos) onde cada texto deve aparecer.
    // Exemplo: paciente posX,posY e largura máxima para o campo.
    const FIELDS = {
      paciente: { page: 0, x: 110, y: 520, maxWidth: 320, baseFontSize: 12, lineHeight: 14 },
      procedimento: { page: 0, x: 110, y: 470, maxWidth: 420, baseFontSize: 11, lineHeight: 13 }
    };

    // Quebra um texto em linhas sem cortar palavras arbitrariamente
    function breakLongText(text, maxCharsPerLine) {
      if (!text) return "";
      const words = text.split(/\s+/);
      const lines = [];
      let cur = "";
      for (const w of words) {
        if ((cur + (cur? " " : "") + w).length <= maxCharsPerLine) {
          cur += (cur? " " : "") + w;
        } else {
          if (cur) lines.push(cur);
          // se palavra sozinha maior que max, corta forçadamente
          if (w.length > maxCharsPerLine) {
            const parts = w.match(new RegExp('.{1,' + maxCharsPerLine + '}', 'g')) || [w];
            for (let i=0;i<parts.length;i++){
              if (i===0) cur = parts[i];
              else lines.push(parts[i]);
            }
            cur = "";
          } else {
            cur = w;
          }
        }
      }
      if (cur) lines.push(cur);
      return lines.join('\\n');
    }

    // Calcula tamanho de fonte aproximado para caber em largura (est. monospaced-ish via char count)
    function computeFontSizeForWidth(text, maxWidth, baseFontSize) {
      // aproximação: assume largura média por caractere = 0.55 * fontSize
      // então fontSize ≈ maxWidth / (textLength * 0.55)
      const len = Math.max(1, text.length);
      const estimated = Math.floor((maxWidth / (len * 0.55)));
      // não aumentar além do baseFontSize
      return Math.max(6, Math.min(baseFontSize, estimated));
    }

    // Gera o PDF preenchido
    document.getElementById('generate').addEventListener('click', async () => {
      const fileInput = document.getElementById('filePdf');
      if (!fileInput.files || !fileInput.files[0]) {
        alert('Escolha o PDF modelo (template) primeiro.');
        return;
      }
      const arrayBuf = await fileInput.files[0].arrayBuffer();
      const paciente = document.getElementById('paciente').value.trim();
      const procedimento = document.getElementById('procedimento').value.trim();
      const strategy = document.getElementById('strategy').value;
      const maxChars = parseInt(document.getElementById('maxChars').value) || 20;

      const pdfDoc = await PDFLib.PDFDocument.load(arrayBuf);
      const pages = pdfDoc.getPages();

      // load font
      const font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);

      // --- PACIENTE: lógica para multiline + ajuste de fonte ---
      const pacField = FIELDS.paciente;
      // quebrar em linhas
      const pacBroken = breakLongText(paciente, maxChars);
      const pacLines = pacBroken.split('\\n');
      // encontrar melhor font size para que a linha mais longa caiba
      let pacFontSize = pacField.baseFontSize;
      if (strategy === 'shrink') {
        // tentar medir pela maior linha
        const longest = pacLines.reduce((a,b)=> a.length>b.length?a:b, pacLines[0]||"");
        pacFontSize = computeFontSizeForWidth(longest, pacField.maxWidth, pacField.baseFontSize);
      } else {
        // multiline: escolher baseFontSize e deixar quebras; se muitas linhas, reduzir um pouco
        if (pacLines.length > 2) pacFontSize = Math.max(8, pacField.baseFontSize - (pacLines.length - 2));
      }

      // --- PROCEDIMENTO: quebra automática por largura (estimativa de chars) e ajuste fino ---
      const procField = FIELDS.procedimento;
      // estimar chars per line for procedimento by width and base font size
      const estCharsPerLineProc = Math.floor(procField.maxWidth / (procField.baseFontSize * 0.55));
      const procBroken = breakLongText(procedimento, estCharsPerLineProc);
      const procLines = procBroken.split('\\n');
      let procFontSize = procField.baseFontSize;
      if (procLines.length > 4) procFontSize = Math.max(7, procField.baseFontSize - (procLines.length - 4));

      // Draw paciente onto page (manually handle newlines)
      const pagePac = pages[pacField.page];
      for (let i = 0; i < pacLines.length; i++) {
        const line = pacLines[i];
        const y = pacField.y - (i * pacField.lineHeight);
        pagePac.drawText(line, {
          x: pacField.x,
          y: y,
          size: pacFontSize,
          font: font,
          maxWidth: pacField.maxWidth,
          // color: rgb(0,0,0) // pdf-lib default is black
        });
      }

      // Draw procedimento
      const pageProc = pages[procField.page];
      for (let i = 0; i < procLines.length; i++) {
        const line = procLines[i];
        const y = procField.y - (i * procField.lineHeight);
        pageProc.drawText(line, {
          x: procField.x,
          y: y,
          size: procFontSize,
          font: font,
          maxWidth: procField.maxWidth
        });
      }

      // Serialize the PDFDocument to bytes (a Uint8Array)
      const pdfBytes = await pdfDoc.save();

      // create blob and download link
      const blob = new Blob([pdfBytes], { type: 'application/pdf' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = 'preenchido.pdf';
      a.textContent = 'Clique aqui se o download não iniciar automaticamente — salvar PDF preenchido';
      document.getElementById('preview').innerHTML = '';
      document.getElementById('preview').appendChild(a);
      // automatic click
      a.click();
    });
  </script>
</body>
</html>
